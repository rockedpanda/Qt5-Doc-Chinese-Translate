<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qquickpainteditem.cpp -->
  <title>QQuickPaintedItem Class | QtQuick 5.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline.css" />
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 5.3</a></li>
<li><a href="qtquick-index.html">Qt Quick</a></li>
<li><a href="qtquick-module.html">C++ Classes</a></li>
<li>QQuickPaintedItem</li>
<li id="buildversion">
Qt 5.3.1 Reference Documentation</li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">QQuickPaintedItem Class</h1>
<!-- $$$QQuickPaintedItem-brief -->
<p>The QQuickPaintedItem class provides a way to use the <a href="../qtgui/qpainter.html">QPainter</a> API in the QML Scene Graph. <a href="#details">More...</a></p>
<!-- @@@QQuickPaintedItem -->
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> </b><tt><span class="preprocessor">#include &lt;QQuickPaintedItem&gt;</span>
</tt></td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <tt>QT += quick</tt></td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qquickitem.html">QQuickItem</a>.</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p></p>
</td></tr></table><ul>
<li><a href="qquickpainteditem-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#PerformanceHint-enum">PerformanceHint</a></b> { FastFBOResizing }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#PerformanceHint-enum">PerformanceHints</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#RenderTarget-enum">RenderTarget</a></b> { Image, FramebufferObject, InvertedYFramebufferObject }</td></tr>
</table>
<a name="properties"></a>
<h2>Properties</h2>
<ul>
<li class="fn"><b><a href="qquickpainteditem.html#contentsScale-prop">contentsScale</a></b> : qreal</li>
<li class="fn"><b><a href="qquickpainteditem.html#contentsSize-prop">contentsSize</a></b> : QSize</li>
<li class="fn"><b><a href="qquickpainteditem.html#fillColor-prop">fillColor</a></b> : QColor</li>
<li class="fn"><b><a href="qquickpainteditem.html#renderTarget-prop">renderTarget</a></b> : RenderTarget</li>
</ul>
<ul>
<li class="fn">23 properties inherited from <a href="qquickitem.html#properties">QQuickItem</a></li>
<li class="fn">1 property inherited from <a href="../qtcore/qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#QQuickPaintedItem">QQuickPaintedItem</a></b>(QQuickItem *<i> parent</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#dtor.QQuickPaintedItem">~QQuickPaintedItem</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#antialiasing">antialiasing</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#contentsBoundingRect">contentsBoundingRect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#contentsScale-prop">contentsScale</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#contentsSize-prop">contentsSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QColor </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#fillColor-prop">fillColor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#mipmap">mipmap</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#opaquePainting">opaquePainting</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#paint">paint</a></b>(QPainter *<i> painter</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> PerformanceHints </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#performanceHints">performanceHints</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> RenderTarget </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#renderTarget-prop">renderTarget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#resetContentsSize">resetContentsSize</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#setAntialiasing">setAntialiasing</a></b>(bool<i> enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#contentsScale-prop">setContentsScale</a></b>(qreal)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#contentsSize-prop">setContentsSize</a></b>(const QSize &amp;)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#fillColor-prop">setFillColor</a></b>(const QColor &amp;)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#setMipmap">setMipmap</a></b>(bool<i> enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#setOpaquePainting">setOpaquePainting</a></b>(bool<i> opaque</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#setPerformanceHint">setPerformanceHint</a></b>(PerformanceHint<i> hint</i>, bool<i> enabled</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#setPerformanceHints">setPerformanceHints</a></b>(PerformanceHints<i> hints</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#renderTarget-prop">setRenderTarget</a></b>(RenderTarget<i> target</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#update">update</a></b>(const QRect &amp;<i> rect</i> = QRect())</td></tr>
</table>
<ul>
<li class="fn">91 public functions inherited from <a href="qquickitem.html#public-functions">QQuickItem</a></li>
<li class="fn">31 public functions inherited from <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
<li class="fn">2 public functions inherited from <a href="../qtqml/qqmlparserstatus.html#public-functions">QQmlParserStatus</a></li>
</ul>
<a name="signals"></a>
<h2>Signals</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#contentsScale-prop">contentsScaleChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#contentsSize-prop">contentsSizeChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#fillColor-prop">fillColorChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#renderTarget-prop">renderTargetChanged</a></b>()</td></tr>
</table>
<ul>
<li class="fn">1 signal inherited from <a href="qquickitem.html#signals">QQuickItem</a></li>
<li class="fn">2 signals inherited from <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="reimplemented-protected-functions"></a>
<h2>Reimplemented Protected Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGNode * </td><td class="memItemRight bottomAlign"><b><a href="qquickpainteditem.html#updatePaintNode">updatePaintNode</a></b>(QSGNode *<i> oldNode</i>, UpdatePaintNodeData *<i> data</i>)</td></tr>
</table>
<ul>
<li class="fn">33 protected functions inherited from <a href="qquickitem.html#protected-functions">QQuickItem</a></li>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 public slot inherited from <a href="qquickitem.html#public-slots">QQuickItem</a></li>
<li class="fn">1 public slot inherited from <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
<li class="fn">1 public variable inherited from <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">10 static public members inherited from <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
<li class="fn">33 protected functions inherited from <a href="qquickitem.html#protected-functions">QQuickItem</a></li>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">2 protected variables inherited from <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QQuickPaintedItem-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QQuickPaintedItem class provides a way to use the <a href="../qtgui/qpainter.html">QPainter</a> API in the QML Scene Graph.</p>
<p>The QQuickPaintedItem makes it possible to use the <a href="../qtgui/qpainter.html">QPainter</a> API with the QML Scene Graph. It sets up a textured rectangle in the Scene Graph and uses a <a href="../qtgui/qpainter.html">QPainter</a> to paint onto the texture. The render target can be either a <a href="../qtgui/qimage.html">QImage</a> or a <a href="../qtgui/qopenglframebufferobject.html">QOpenGLFramebufferObject</a>. When the render target is a <a href="../qtgui/qimage.html">QImage</a>, <a href="../qtgui/qpainter.html">QPainter</a> first renders into the image then the content is uploaded to the texture. When a <a href="../qtgui/qopenglframebufferobject.html">QOpenGLFramebufferObject</a> is used, <a href="../qtgui/qpainter.html">QPainter</a> paints directly onto the texture. Call <a href="qquickpainteditem.html#update">update</a>() to trigger a repaint.</p>
<p>To enable <a href="../qtgui/qpainter.html">QPainter</a> to do anti-aliased rendering, use <a href="qquickpainteditem.html#setAntialiasing">setAntialiasing</a>().</p>
<p>To write your own painted item, you first create a subclass of QQuickPaintedItem, and then start by implementing its only pure virtual public function: <a href="qquickpainteditem.html#paint">paint</a>(), which implements the actual painting. To get the size of the area painted by the item, use <a href="qquickpainteditem.html#contentsBoundingRect">contentsBoundingRect</a>().</p>
</div>
<!-- @@@QQuickPaintedItem -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$PerformanceHint$$$FastFBOResizing -->
<h3 class="flags"><a name="PerformanceHint-enum"></a>enum QQuickPaintedItem::<span class="name">PerformanceHint</span><br/>flags QQuickPaintedItem::<span class="name">PerformanceHints</span></h3>
<p>This enum describes flags that you can enable to improve rendering performance in <a href="qquickpainteditem.html">QQuickPaintedItem</a>. By default, none of these flags are set.</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>QQuickPaintedItem::FastFBOResizing</tt></td><td class="topAlign"><tt>0x1</tt></td><td class="topAlign">If your item gets resized often and you are using the <a href="qquickpainteditem.html#RenderTarget-enum">QQuickPaintedItem::FramebufferObject</a> render target, set this flag to true to reduce the item resizing time at the cost of using more graphics memory. Resizing a Framebuffer object is a costly operation, by enabling this property the Framebuffer Object will use a texture larger than the actual size of the item to avoid as much as possible resizing it.</td></tr>
</table>
<p>The PerformanceHints type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;PerformanceHint&gt;. It stores an OR combination of PerformanceHint values.</p>
<!-- @@@PerformanceHint -->
<!-- $$$RenderTarget$$$Image$$$FramebufferObject$$$InvertedYFramebufferObject -->
<h3 class="fn"><a name="RenderTarget-enum"></a>enum QQuickPaintedItem::<span class="name">RenderTarget</span></h3>
<p>This enum describes <a href="qquickpainteditem.html">QQuickPaintedItem</a>'s render targets. The render target is the surface <a href="../qtgui/qpainter.html">QPainter</a> paints onto before the item is rendered on screen.</p>
<table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><tt>QQuickPaintedItem::Image</tt></td><td class="topAlign"><tt>0</tt></td><td class="topAlign">The default; <a href="../qtgui/qpainter.html">QPainter</a> paints into a <a href="../qtgui/qimage.html">QImage</a> using the raster paint engine. The image's content needs to be uploaded to graphics memory afterward, this operation can potentially be slow if the item is large. This render target allows high quality anti-aliasing and fast item resizing.</td></tr>
<tr><td class="topAlign"><tt>QQuickPaintedItem::FramebufferObject</tt></td><td class="topAlign"><tt>1</tt></td><td class="topAlign"><a href="../qtgui/qpainter.html">QPainter</a> paints into a <a href="../qtgui/qopenglframebufferobject.html">QOpenGLFramebufferObject</a> using the GL paint engine. Painting can be faster as no texture upload is required, but anti-aliasing quality is not as good as if using an image. This render target allows faster rendering in some cases, but you should avoid using it if the item is resized often.</td></tr>
<tr><td class="topAlign"><tt>QQuickPaintedItem::InvertedYFramebufferObject</tt></td><td class="topAlign"><tt>2</tt></td><td class="topAlign">Exactly as for FramebufferObject above, except once the painting is done, prior to rendering the painted image is flipped about the x-axis so that the top-most pixels are now at the bottom. Since this is done with the OpenGL texture coordinates it is a much faster way to achieve this effect than using a painter transform.</td></tr>
</table>
<p><b>See also </b><a href="qquickpainteditem.html#renderTarget-prop">setRenderTarget</a>().</p>
<!-- @@@RenderTarget -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$contentsScale-prop$$$contentsScale$$$setContentsScaleqreal$$$contentsScaleChanged -->
<h3 class="fn"><a name="contentsScale-prop"></a><span class="name">contentsScale</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>This property holds the scale of the contents.</p>
<p>All painting happening in <a href="qquickpainteditem.html#paint">paint</a>() is scaled by the contents scale. This is distinct from the scale of the item in regards to <a href="qquickitem.html#scale-prop">scale</a>().</p>
<p>The default value is 1.</p>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>contentsScale</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setContentsScale</b></span>(qreal)</td></tr>
</table>
<p><b>Notifier signal:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>contentsScaleChanged</b></span>()</td></tr>
</table>
<!-- @@@contentsScale -->
<!-- $$$contentsSize-prop$$$contentsSize$$$setContentsSizeconstQSize&$$$contentsSizeChanged -->
<h3 class="fn"><a name="contentsSize-prop"></a><span class="name">contentsSize</span> : <span class="type"><a href="../qtcore/qsize.html">QSize</a></span></h3>
<p>This property holds the size of the contents.</p>
<p>The contents size is the size of the item in regards to how it is painted using the <a href="qquickpainteditem.html#paint">paint</a>() function. This is distinct from the size of the item in regards to <a href="qquickitem.html#height-prop">height</a>() and <a href="qquickitem.html#width-prop">width</a>().</p>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>contentsSize</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setContentsSize</b></span>(const QSize &amp;)</td></tr>
</table>
<p><b>Notifier signal:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>contentsSizeChanged</b></span>()</td></tr>
</table>
<!-- @@@contentsSize -->
<!-- $$$fillColor-prop$$$fillColor$$$setFillColorconstQColor&$$$fillColorChanged -->
<h3 class="fn"><a name="fillColor-prop"></a><span class="name">fillColor</span> : <span class="type"><a href="../qtgui/qcolor.html">QColor</a></span></h3>
<p>This property holds the item's background fill color.</p>
<p>By default, the fill color is set to <a href="../qtcore/qt.html#GlobalColor-enum">Qt::transparent</a>.</p>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QColor </td><td class="memItemRight bottomAlign"><span class="name"><b>fillColor</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFillColor</b></span>(const QColor &amp;)</td></tr>
</table>
<p><b>Notifier signal:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>fillColorChanged</b></span>()</td></tr>
</table>
<!-- @@@fillColor -->
<!-- $$$renderTarget-prop$$$renderTarget$$$setRenderTargetRenderTarget$$$renderTargetChanged -->
<h3 class="fn"><a name="renderTarget-prop"></a><span class="name">renderTarget</span> : <span class="type"><a href="qquickpainteditem.html#RenderTarget-enum">RenderTarget</a></span></h3>
<p>This property holds the item's render target.</p>
<p>This property defines which render target the <a href="../qtgui/qpainter.html">QPainter</a> renders into, it can be either QSGPaintedItem::Image, QSGPaintedItem::FramebufferObject or QSGPaintedItem::InvertedYFramebufferObject.</p>
<p>Each has certain benefits, typically performance versus quality. Using a framebuffer object avoids a costly upload of the image contents to the texture in graphics memory, while using an image enables high quality anti-aliasing.</p>
<p><b>Warning:</b> Resizing a framebuffer object is a costly operation, avoid using the <a href="qquickpainteditem.html#RenderTarget-enum">QQuickPaintedItem::FramebufferObject</a> render target if the item gets resized often.</p>
<p>By default, the render target is <a href="qquickpainteditem.html#RenderTarget-enum">QQuickPaintedItem::Image</a>.</p>
<p><b>Access functions:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> RenderTarget </td><td class="memItemRight bottomAlign"><span class="name"><b>renderTarget</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setRenderTarget</b></span>(RenderTarget<i> target</i>)</td></tr>
</table>
<p><b>Notifier signal:</b></p>
<table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>renderTargetChanged</b></span>()</td></tr>
</table>
<!-- @@@renderTarget -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickPaintedItem[overload1]$$$QQuickPaintedItemQQuickItem* -->
<h3 class="fn"><a name="QQuickPaintedItem"></a>QQuickPaintedItem::<span class="name">QQuickPaintedItem</span>(<span class="type"><a href="qquickitem.html">QQuickItem</a></span> *<i> parent</i> = 0)</h3>
<p>Constructs a <a href="qquickpainteditem.html">QQuickPaintedItem</a> with the given <i>parent</i> item.</p>
<!-- @@@QQuickPaintedItem -->
<!-- $$$~QQuickPaintedItem[overload1]$$$~QQuickPaintedItem -->
<h3 class="fn"><a name="dtor.QQuickPaintedItem"></a>QQuickPaintedItem::<span class="name">~QQuickPaintedItem</span>()<tt> [virtual]</tt></h3>
<p>Destroys the <a href="qquickpainteditem.html">QQuickPaintedItem</a>.</p>
<!-- @@@~QQuickPaintedItem -->
<!-- $$$antialiasing[overload1]$$$antialiasing -->
<h3 class="fn"><a name="antialiasing"></a><span class="type">bool</span> QQuickPaintedItem::<span class="name">antialiasing</span>() const</h3>
<p>Returns true if antialiased painting is enabled; otherwise, false is returned.</p>
<p>By default, antialiasing is not enabled.</p>
<p><b>See also </b><a href="qquickpainteditem.html#setAntialiasing">setAntialiasing</a>().</p>
<!-- @@@antialiasing -->
<!-- $$$contentsBoundingRect[overload1]$$$contentsBoundingRect -->
<h3 class="fn"><a name="contentsBoundingRect"></a><span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> QQuickPaintedItem::<span class="name">contentsBoundingRect</span>() const</h3>
<p>This function returns the outer bounds of the item as a rectangle; all painting must be restricted to inside an item's bounding rect.</p>
<p>If the contents size has not been set it reflects the size of the item; otherwise it reflects the contents size scaled by the contents scale.</p>
<p>Use this function to know the area painted by the item.</p>
<p><b>See also </b><a href="qquickitem.html#width-prop">QQuickItem::width</a>(), <a href="qquickitem.html#height-prop">QQuickItem::height</a>(), <a href="qquickpainteditem.html#contentsSize-prop">contentsSize</a>(), and <a href="qquickpainteditem.html#contentsScale-prop">contentsScale</a>().</p>
<!-- @@@contentsBoundingRect -->
<!-- $$$mipmap[overload1]$$$mipmap -->
<h3 class="fn"><a name="mipmap"></a><span class="type">bool</span> QQuickPaintedItem::<span class="name">mipmap</span>() const</h3>
<p>Returns true if mipmaps are enabled; otherwise, false is returned.</p>
<p>By default, mipmapping is not enabled.</p>
<p><b>See also </b><a href="qquickpainteditem.html#setMipmap">setMipmap</a>().</p>
<!-- @@@mipmap -->
<!-- $$$opaquePainting[overload1]$$$opaquePainting -->
<h3 class="fn"><a name="opaquePainting"></a><span class="type">bool</span> QQuickPaintedItem::<span class="name">opaquePainting</span>() const</h3>
<p>Returns true if this item is opaque; otherwise, false is returned.</p>
<p>By default, painted items are not opaque.</p>
<p><b>See also </b><a href="qquickpainteditem.html#setOpaquePainting">setOpaquePainting</a>().</p>
<!-- @@@opaquePainting -->
<!-- $$$paint[overload1]$$$paintQPainter* -->
<h3 class="fn"><a name="paint"></a><span class="type">void</span> QQuickPaintedItem::<span class="name">paint</span>(<span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> *<i> painter</i>)<tt> [pure virtual]</tt></h3>
<p>This function, which is usually called by the QML Scene Graph, paints the contents of an item in local coordinates.</p>
<p>The function is called after the item has been filled with the <a href="qquickpainteditem.html#fillColor-prop">fillColor</a>.</p>
<p>Reimplement this function in a <a href="qquickpainteditem.html">QQuickPaintedItem</a> subclass to provide the item's painting implementation, using <i>painter</i>.</p>
<p><b>Note: </b>The QML Scene Graph uses two separate threads, the main thread does things such as processing events or updating animations while a second thread does the actual OpenGL rendering. As a consequence, paint() is not called from the main GUI thread but from the GL enabled renderer thread. At the moment paint() is called, the GUI thread is blocked and this is therefore thread-safe.</p><p><b>Warning:</b> Extreme caution must be used when creating QObjects, emitting signals, starting timers and similar inside this function as these will have affinity to the rendering thread.</p>
<!-- @@@paint -->
<!-- $$$performanceHints[overload1]$$$performanceHints -->
<h3 class="fn"><a name="performanceHints"></a><span class="type"><a href="qquickpainteditem.html#PerformanceHint-enum">PerformanceHints</a></span> QQuickPaintedItem::<span class="name">performanceHints</span>() const</h3>
<p>Returns the performance hints.</p>
<p>By default, no performance hint is enabled.</p>
<p><b>See also </b><a href="qquickpainteditem.html#setPerformanceHint">setPerformanceHint</a>() and <a href="qquickpainteditem.html#setPerformanceHints">setPerformanceHints</a>().</p>
<!-- @@@performanceHints -->
<!-- $$$resetContentsSize[overload1]$$$resetContentsSize -->
<h3 class="fn"><a name="resetContentsSize"></a><span class="type">void</span> QQuickPaintedItem::<span class="name">resetContentsSize</span>()</h3>
<p>This convenience function is equivalent to calling setContentsSize(QSize()).</p>
<!-- @@@resetContentsSize -->
<!-- $$$setAntialiasing[overload1]$$$setAntialiasingbool -->
<h3 class="fn"><a name="setAntialiasing"></a><span class="type">void</span> QQuickPaintedItem::<span class="name">setAntialiasing</span>(<span class="type">bool</span><i> enable</i>)</h3>
<p>If <i>enable</i> is true, antialiased painting is enabled.</p>
<p>By default, antialiasing is not enabled.</p>
<p><b>See also </b><a href="qquickpainteditem.html#antialiasing">antialiasing</a>().</p>
<!-- @@@setAntialiasing -->
<!-- $$$setMipmap[overload1]$$$setMipmapbool -->
<h3 class="fn"><a name="setMipmap"></a><span class="type">void</span> QQuickPaintedItem::<span class="name">setMipmap</span>(<span class="type">bool</span><i> enable</i>)</h3>
<p>If <i>enable</i> is true, mipmapping is enabled on the associated texture.</p>
<p>Mipmapping increases rendering speed and reduces aliasing artifacts when the item is scaled down.</p>
<p>By default, mipmapping is not enabled.</p>
<p><b>See also </b><a href="qquickpainteditem.html#mipmap">mipmap</a>().</p>
<!-- @@@setMipmap -->
<!-- $$$setOpaquePainting[overload1]$$$setOpaquePaintingbool -->
<h3 class="fn"><a name="setOpaquePainting"></a><span class="type">void</span> QQuickPaintedItem::<span class="name">setOpaquePainting</span>(<span class="type">bool</span><i> opaque</i>)</h3>
<p>If <i>opaque</i> is true, the item is opaque; otherwise, it is considered as translucent.</p>
<p>Opaque items are not blended with the rest of the scene, you should set this to true if the content of the item is opaque to speed up rendering.</p>
<p>By default, painted items are not opaque.</p>
<p><b>See also </b><a href="qquickpainteditem.html#opaquePainting">opaquePainting</a>().</p>
<!-- @@@setOpaquePainting -->
<!-- $$$setPerformanceHint[overload1]$$$setPerformanceHintPerformanceHintbool -->
<h3 class="fn"><a name="setPerformanceHint"></a><span class="type">void</span> QQuickPaintedItem::<span class="name">setPerformanceHint</span>(<span class="type"><a href="qquickpainteditem.html#PerformanceHint-enum">PerformanceHint</a></span><i> hint</i>, <span class="type">bool</span><i> enabled</i> = true)</h3>
<p>Sets the given performance <i>hint</i> on the item if <i>enabled</i> is true; otherwise clears the performance hint.</p>
<p>By default, no performance hint is enabled/</p>
<p><b>See also </b><a href="qquickpainteditem.html#setPerformanceHints">setPerformanceHints</a>() and <a href="qquickpainteditem.html#performanceHints">performanceHints</a>().</p>
<!-- @@@setPerformanceHint -->
<!-- $$$setPerformanceHints[overload1]$$$setPerformanceHintsPerformanceHints -->
<h3 class="fn"><a name="setPerformanceHints"></a><span class="type">void</span> QQuickPaintedItem::<span class="name">setPerformanceHints</span>(<span class="type"><a href="qquickpainteditem.html#PerformanceHint-enum">PerformanceHints</a></span><i> hints</i>)</h3>
<p>Sets the performance hints to <i>hints</i></p>
<p>By default, no performance hint is enabled/</p>
<p><b>See also </b><a href="qquickpainteditem.html#setPerformanceHint">setPerformanceHint</a>() and <a href="qquickpainteditem.html#performanceHints">performanceHints</a>().</p>
<!-- @@@setPerformanceHints -->
<!-- $$$update[overload1]$$$updateconstQRect& -->
<h3 class="fn"><a name="update"></a><span class="type">void</span> QQuickPaintedItem::<span class="name">update</span>(const <span class="type"><a href="../qtcore/qrect.html">QRect</a></span> &amp;<i> rect</i> = QRect())</h3>
<p>Schedules a redraw of the area covered by <i>rect</i> in this item. You can call this function whenever your item needs to be redrawn, such as if it changes appearance or size.</p>
<p>This function does not cause an immediate paint; instead it schedules a paint request that is processed by the QML Scene Graph when the next frame is rendered. The item will only be redrawn if it is visible.</p>
<p>Note that calling this function will trigger a repaint of the whole scene.</p>
<p><b>See also </b><a href="qquickpainteditem.html#paint">paint</a>().</p>
<!-- @@@update -->
<!-- $$$updatePaintNode[overload1]$$$updatePaintNodeQSGNode*UpdatePaintNodeData* -->
<h3 class="fn"><a name="updatePaintNode"></a><span class="type"><a href="qsgnode.html">QSGNode</a></span> * QQuickPaintedItem::<span class="name">updatePaintNode</span>(<span class="type"><a href="qsgnode.html">QSGNode</a></span> *<i> oldNode</i>, <span class="type"><a href="qquickitem-updatepaintnodedata.html">UpdatePaintNodeData</a></span> *<i> data</i>)<tt> [virtual protected]</tt></h3>
<p>Reimplemented from <a href="qquickitem.html#updatePaintNode">QQuickItem::updatePaintNode</a>().</p>
<!-- @@@updatePaintNode -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2014 Digia Plc and/or its
   subsidiaries. Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Digia, Qt and their respective logos are trademarks of Digia Plc     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
