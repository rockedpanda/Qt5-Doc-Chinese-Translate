<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qqmlabstractprofileradapter.cpp -->
  <title>QQmlAbstractProfilerAdapter Class | QtQml 5.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline.css" />
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 5.3</a></li>
<li><a href="qtqml-index.html">Qt QML</a></li>
<li><a href="qtqml-module.html">C++ Classes</a></li>
<li>QQmlAbstractProfilerAdapter</li>
<li id="buildversion">
Qt 5.3.1 Reference Documentation</li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">QQmlAbstractProfilerAdapter Class</h1>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> </b><tt><span class="preprocessor">#include &lt;QQmlAbstractProfilerAdapter&gt;</span>
</tt></td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> <tt>QT += qml</tt></td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html">QObject</a>.</td></tr></table><ul>
<li><a href="qqmlabstractprofileradapter-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#QQmlAbstractProfilerAdapter">QQmlAbstractProfilerAdapter</a></b>(QQmlProfilerService *<i> service</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#dtor.QQmlAbstractProfilerAdapter">~QQmlAbstractProfilerAdapter</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#isRunning">isRunning</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#reportData">reportData</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#sendMessages">sendMessages</a></b>(qint64<i> until</i>, QList&lt;QByteArray&gt; &amp;<i> messages</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#startProfiling">startProfiling</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#startWaiting">startWaiting</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#stopProfiling">stopProfiling</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#stopWaiting">stopWaiting</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#synchronize">synchronize</a></b>(const QElapsedTimer &amp;<i> timer</i>)</td></tr>
</table>
<ul>
<li class="fn">31 public functions inherited from <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
</ul>
<a name="signals"></a>
<h2>Signals</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#dataRequested">dataRequested</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#profilingDisabled">profilingDisabled</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#profilingDisabledWhileWaiting">profilingDisabledWhileWaiting</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#profilingEnabled">profilingEnabled</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#profilingEnabledWhileWaiting">profilingEnabledWhileWaiting</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlabstractprofileradapter.html#referenceTimeKnown">referenceTimeKnown</a></b>(const QElapsedTimer &amp;<i> timer</i>)</td></tr>
</table>
<ul>
<li class="fn">2 signals inherited from <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li class="fn">1 property inherited from <a href="../qtcore/qobject.html#properties">QObject</a></li>
<li class="fn">1 public slot inherited from <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
<li class="fn">1 public variable inherited from <a href="../qtcore/qobject.html#public-variables">QObject</a></li>
<li class="fn">10 static public members inherited from <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">2 protected variables inherited from <a href="../qtcore/qobject.html#protected-variables">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QQmlAbstractProfilerAdapter-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>Abstract base class for all adapters between profilers and the QQmlProfilerService. Adapters have to retrieve profiler-specific data and convert it to the format sent over the wire. Adapters must live in the QDebugServer thread but the actual profilers can live in different threads. The recommended way to deal with this is passing the profiling data through a signal/slot connection.</p>
</div>
<!-- @@@QQmlAbstractProfilerAdapter -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQmlAbstractProfilerAdapter[overload1]$$$QQmlAbstractProfilerAdapterQQmlProfilerService* -->
<h3 class="fn"><a name="QQmlAbstractProfilerAdapter"></a>QQmlAbstractProfilerAdapter::<span class="name">QQmlAbstractProfilerAdapter</span>(<span class="type">QQmlProfilerService</span> *<i> service</i>)</h3>
<!-- @@@QQmlAbstractProfilerAdapter -->
<!-- $$$~QQmlAbstractProfilerAdapter[overload1]$$$~QQmlAbstractProfilerAdapter -->
<h3 class="fn"><a name="dtor.QQmlAbstractProfilerAdapter"></a>QQmlAbstractProfilerAdapter::<span class="name">~QQmlAbstractProfilerAdapter</span>()<tt> [virtual]</tt></h3>
<!-- @@@~QQmlAbstractProfilerAdapter -->
<!-- $$$dataRequested[overload1]$$$dataRequested -->
<h3 class="fn"><a name="dataRequested"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">dataRequested</span>()<tt> [signal]</tt></h3>
<p>Signals that data has been requested by the <tt>QQmlProfilerService</tt>. This signal should be connected to a slot in the profiler and the profiler should then transfer its currently available profiling data to the adapter as soon as possible.</p>
<!-- @@@dataRequested -->
<!-- $$$isRunning[overload1]$$$isRunning -->
<h3 class="fn"><a name="isRunning"></a><span class="type">bool</span> QQmlAbstractProfilerAdapter::<span class="name">isRunning</span>() const</h3>
<p>Returns if the profiler is currently running. The profiler is considered to be running after <tt>startProfiling()</tt> has been called until <tt>stopProfiling()</tt> is called. That is independent of <tt>waiting</tt>. The profiler may be running and waiting at the same time.</p>
<!-- @@@isRunning -->
<!-- $$$profilingDisabled[overload1]$$$profilingDisabled -->
<h3 class="fn"><a name="profilingDisabled"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">profilingDisabled</span>()<tt> [signal]</tt></h3>
<p>This signal is emitted if <tt>stopProfiling()</tt> is called while the profiler is not considered to be waiting. The profiler is expected to handle the signal asynchronously.</p>
<!-- @@@profilingDisabled -->
<!-- $$$profilingDisabledWhileWaiting[overload1]$$$profilingDisabledWhileWaiting -->
<h3 class="fn"><a name="profilingDisabledWhileWaiting"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">profilingDisabledWhileWaiting</span>()<tt> [signal]</tt></h3>
<p>This signal is emitted if <tt>stopProfiling()</tt> is called while the profiler is considered to be waiting. In many cases this signal can be connected with a <tt>Qt::DirectConnection</tt>.</p>
<!-- @@@profilingDisabledWhileWaiting -->
<!-- $$$profilingEnabled[overload1]$$$profilingEnabled -->
<h3 class="fn"><a name="profilingEnabled"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">profilingEnabled</span>()<tt> [signal]</tt></h3>
<p>This signal is emitted if <tt>startProfiling()</tt> is called while the profiler is not considered to be waiting. The profiler is expected to handle the signal asynchronously.</p>
<!-- @@@profilingEnabled -->
<!-- $$$profilingEnabledWhileWaiting[overload1]$$$profilingEnabledWhileWaiting -->
<h3 class="fn"><a name="profilingEnabledWhileWaiting"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">profilingEnabledWhileWaiting</span>()<tt> [signal]</tt></h3>
<p>This signal is emitted if <tt>startProfiling()</tt> is called while the profiler is considered to be waiting. In many cases this signal can be connected with a <tt>Qt::DirectConnection</tt>. By starting the profiler synchronously when the QML engine starts instead of waiting for the first iteration of the event loop the engine startup can be profiled.</p>
<!-- @@@profilingEnabledWhileWaiting -->
<!-- $$$referenceTimeKnown[overload1]$$$referenceTimeKnownconstQElapsedTimer& -->
<h3 class="fn"><a name="referenceTimeKnown"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">referenceTimeKnown</span>(const <span class="type"><a href="../qtcore/qelapsedtimer.html">QElapsedTimer</a></span> &amp;<i> timer</i>)<tt> [signal]</tt></h3>
<p>This signal is used to synchronize the profiler's timer to the QQmlProfilerservice's. The profiler is expected to save <i>timer</i> and use it for timestamps on its data.</p>
<!-- @@@referenceTimeKnown -->
<!-- $$$reportData[overload1]$$$reportData -->
<h3 class="fn"><a name="reportData"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">reportData</span>()</h3>
<p>Make the profiler report its current data without stopping the collection. The same (and additional) data can later be requested again with <tt>stopProfiling()</tt> or <tt>reportData()</tt>.</p>
<!-- @@@reportData -->
<!-- $$$sendMessages[overload1]$$$sendMessagesqint64QList<QByteArray>& -->
<h3 class="fn"><a name="sendMessages"></a><span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span> QQmlAbstractProfilerAdapter::<span class="name">sendMessages</span>(<span class="type"><a href="../qtcore/qtglobal.html#qint64-typedef">qint64</a></span><i> until</i>, <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span>&gt; &amp;<i> messages</i>)<tt> [pure virtual]</tt></h3>
<p>Append the messages up to the timestamp <i>until</i>, chronologically sorted, to <i>messages</i>. Keep track of the messages already sent and with each subsequent call to this method start with the first one not yet sent. Messages that have been sent can be deleted. When new data from the profiler arrives the information about the last sent message must be reset. Return the timestamp of the next message after <i>until</i> or <tt>-1</tt> if there is no such message. The profiler service keeps a list of adapters, sorted by time of next message and keeps querying the first one to send messages up to the time of the second one. Like that we get chronologically sorted messages and can occasionally post the messages to exploit parallelism and save memory.</p>
<!-- @@@sendMessages -->
<!-- $$$startProfiling[overload1]$$$startProfiling -->
<h3 class="fn"><a name="startProfiling"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">startProfiling</span>()</h3>
<p>Emits either <tt>profilingEnabled()</tt> or <tt>profilingEnabledWhileWaiting()</tt>, depending on <tt>waiting</tt>. If the profiler's thread is waiting for an initial start signal we can emit the signal over a <tt>Qt::DirectConnection</tt> to avoid the delay of the event loop.</p>
<!-- @@@startProfiling -->
<!-- $$$startWaiting[overload1]$$$startWaiting -->
<h3 class="fn"><a name="startWaiting"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">startWaiting</span>()</h3>
<p>Consider the profiler to be waiting from now on. While the profiler is waiting it can be directly accessed even if it is in a different thread. This method should only be called if it is actually safe to do so.</p>
<!-- @@@startWaiting -->
<!-- $$$stopProfiling[overload1]$$$stopProfiling -->
<h3 class="fn"><a name="stopProfiling"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">stopProfiling</span>()</h3>
<p>Emits either <tt>profilingDisabled()</tt> or <tt>profilingDisabledWhileWaiting()</tt>, depending on <tt>waiting</tt>. If the profiler's thread is waiting for an initial start signal we can emit the signal over a <tt>Qt::DirectConnection</tt> to avoid the delay of the event loop. This should trigger the profiler to report its collected data and subsequently delete it.</p>
<!-- @@@stopProfiling -->
<!-- $$$stopWaiting[overload1]$$$stopWaiting -->
<h3 class="fn"><a name="stopWaiting"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">stopWaiting</span>()</h3>
<p>Consider the profiler not to be waiting anymore. If it lives in a different threads any requests for it have to be done via a queued connection then.</p>
<!-- @@@stopWaiting -->
<!-- $$$synchronize[overload1]$$$synchronizeconstQElapsedTimer& -->
<h3 class="fn"><a name="synchronize"></a><span class="type">void</span> QQmlAbstractProfilerAdapter::<span class="name">synchronize</span>(const <span class="type"><a href="../qtcore/qelapsedtimer.html">QElapsedTimer</a></span> &amp;<i> timer</i>)</h3>
<p>Synchronize the profiler to <i>timer</i>. This emits <tt>referenceTimeKnown()</tt>.</p>
<!-- @@@synchronize -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2014 Digia Plc and/or its
   subsidiaries. Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Digia, Qt and their respective logos are trademarks of Digia Plc     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
